<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercise 1: Loading the Data</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2 {
            color: #2c3e50;
        }
        code {
            background-color: #f4f4f4;
            padding: 5px;
            border-radius: 3px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-left: 3px solid #ccc;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        a {
            color: #2980b9;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>


    
<body>
    <p># loading the libraries into the notebook
import seaborn as sns
import pandas as pd
from pysal.lib import weights
from pysal.explore import esda
import geopandas as gpd
import numpy as np
import contextily as ctx
import matplotlib.pyplot as plt</p>

        <h1>Question 1: Use PySAL to create a contiguity-based weight matrix (W) for a given spatial dataset of polygons. Write a function create_contiguity_weights that:</h1>
<p>    
    Reads in a shapefile of polygons.
    Constructs a Queen contiguity-based spatial weights matrix.
    Returns the weight matrix.
</p> 
<h2>Code:</h2>
    <p><pre><code>
        # creating a queen contiguity based spatial weight matrix to test whether neigbourhoods are adjacent
# with the queen contiguity based spatial weight matrix iyou can test wether these observations (neighbourhoods) share a vortex
# vortex = (a single point)
w_queen = weights.Queen.from_dataframe(gdf, ids='gebied_naam')
w_queen

# opening the geodataframe to find the name (row) of one of the districts (gebieds_naam, column)
gdf

# testing wether the queen contiguity based spatial weight matrix worked for on of the districts
w_queen['Diamantbuurt']

# writing a function "reate_contiguity_weigh" that includes all the previous steps 
# to succesfully create create a contiguity-based weight matrix (W) for a given spatial dataset of polygons
# that aslo returns the weight matrix ("return" is something you can only do with a function)
def create_contiguity_weights(geodataframe):
    gdf = gpd.read_file(geodataframe)
    w_queen = weights.Queen.from_dataframe(gdf, ids='gebied_naam')
    return w_queen
    </code></pre></p>


    <h1>Question 2: Write a function calculate_morans_i that:</h1>
<p>
    Takes a spatial weight matrix W and an attribute array y.
    Calculates Moran’s I for the given attribute array.
    Returns the Moran’s I value and its p-value.
</p> 
<h2>Code:</h2>
    <p><pre><code>
        from esda.moran import Moran
#First we must define the geodatabase, it was defined earlier in the previous function but this function
#cannot look inside the other so we must define it again
gdf = gpd.read_file(geodataframe)

#We create a function called calculate_morans_i which takes the contiguity matrix
#from exercise 1 and calculates morans i with it
def calculate_morans_i(w_queen):
    
    #First the function standardizes the rows
    w_queen.transform = 'r'

    # Then it defines Y as a row from the dataframe
    Y = gdf['opp_gebied_ha'].values

    # We then use the moran function to calculate morans I with 
    #the information from Y and the weighted matirx W
    moran = Moran(Y, w_queen)
   
    #The function then retunr Morans I
    return moran

#We first define moran
moran = calculate_morans_i(w_queen)

#Which then allows the print functions to actually print Morans I and the P value
print(f"Moran's I: {moran.I}")
print(f"P-value: {moran.p_sim}")

#Made by Marco
    </code></pre></p>


        <h1>Question 3: Create a function standardize_weights that:</h1>
<p>
    Takes a spatial weight matrix W.
    Standardizes it so that the weights of each row sum to one.
    Returns the standardized weight matrix.
</p> 
<h2>Code:</h2>
    <p><pre><code>
        # create a function "standardize_weights" with the spatial weight matrix(w_queen) as a parameter 
# parameters in functions act as place holders, it specifies what kind of input the function expects
# an argument is the actual value you pass into the function when you call it, substituting the parameter
# in this case w_queen is the variable that holds the spatial weight matrix
# the following function standardizes this w_quuen matrix by using .transform 
# in this case row-based transformation is needed, to make sure every row of the matrix sums up to one
# 'R' stands for row-standardization
from libpysal import weights

def standardize_weights(w_queen):
    w_queen.transform = 'R'
    return w_queen


# w_queen is the spatial weights matrix
# you can check the standardized values by printing .... 
w_standardized = standardize_weights(w_queen)
print(w_standardized['Diamantbuurt'])

#Made by Titus
    </code></pre></p>


        <h1>Question 4: Write a function create_distance_weights that:</h1>
<p>
    Takes a set of point coordinates and a threshold distance.
    Constructs a distance-based spatial weight matrix where all points within the threshold distance are assigned a weight.
    Returns the weight matrix.
</p> 
<h2>Code:</h2>
    <p><pre><code>
    </code></pre></p>


        <h1>Question 5: Using PySAL, write a function plot_moran that:
</h1>
<p>
    Takes a spatial weights matrix W and an attribute array y.
    Creates and displays a Moran plot for the attribute.
    Saves the Moran plot as an image file.
</p> 
<h2>Code:</h2>
    <p><pre><code>
    </code></pre></p>

</body>
</html>









